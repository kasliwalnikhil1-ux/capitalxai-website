---
interface Props {
  typewriterPhrases: string[];
  headlineBottom: string;
  subheading: string;
  primaryCta: { label: string; href: string };
  secondaryCta: { label: string; href: string };
}

const { typewriterPhrases, headlineBottom, subheading, primaryCta, secondaryCta } = Astro.props;
const subheadingHtml = subheading.replaceAll('\n', ' <br class="desktop-break" />');
---

<section id="hero" class="hero" aria-labelledby="hero-heading">
  <div class="hero-bg" aria-hidden="true">
    <div class="hero-glow" />
    <div class="hero-vignette" />
  </div>
  <div class="container hero-inner">
    <h1 id="hero-heading" class="hero-headline">
      <span class="headline-top">Raise <span
          class="typewriter-text"
          data-phrases={JSON.stringify(typewriterPhrases)}
        >{typewriterPhrases[0]}</span><span class="typewriter-cursor" aria-hidden="true">|</span></span>
      <span class="headline-bottom">
        {headlineBottom}
        <span class="headline-rocket" aria-hidden="true">ðŸš€</span>
      </span>
    </h1>
    <p class="hero-subheading" set:html={subheadingHtml} />
    <div class="hero-ctas">
      <a href={primaryCta.href} class="btn btn-primary" target="_blank" rel="noopener noreferrer">
        {primaryCta.label}<span class="btn-arrow" aria-hidden="true">&rarr;</span>
      </a>
      <a href={secondaryCta.href} class="btn btn-secondary" target="_blank" rel="noopener noreferrer">
        {secondaryCta.label}
      </a>
    </div>

    <div class="hero-preview" aria-hidden="true">
      <div class="preview-stack">
        <div class="preview-img-wrap preview-center" style="--mask-url: url('/center.png')">
          <img class="preview-center" src="/center.png" alt="" loading="eager" decoding="async" />
        </div>
        <div class="preview-img-wrap preview-left" style="--mask-url: url('/left.gif')">
          <img class="preview-left" src="/left.gif" alt="" loading="eager" decoding="async" />
        </div>
        <div class="preview-img-wrap preview-right" style="--mask-url: url('/right.gif')">
          <img class="preview-right" src="/right.gif" alt="" loading="eager" decoding="async" />
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  .hero {
    position: relative;
    min-height: 620px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding-block: 5.5rem 6rem;
    overflow: hidden;
    overflow-x: hidden;
    width: 100%;
    max-width: 100%;
    /* Slightly lighter base like the screenshot */
    background: #0b1020;
  }

  .hero-bg {
    position: absolute;
    inset: 0;
    z-index: 0;
  }

  .hero-glow {
    position: absolute;
    left: -10%;
    bottom: -20%;
    width: 70%;
    height: 80%;
    background: radial-gradient(
      ellipse at center,
      rgba(255, 200, 100, 0.25) 0%,
      rgba(255, 140, 180, 0.2) 25%,
      rgba(180, 100, 255, 0.2) 50%,
      rgba(100, 180, 255, 0.15) 75%,
      transparent 100%
    );
    filter: blur(80px);
    pointer-events: none;
  }

  @media (max-width: 768px) {
    .hero-glow {
      left: -30%;
      bottom: -10%;
      width: 100%;
      height: 60%;
    }
  }

  .hero-vignette {
    display: none;
  }

  .hero-inner {
    position: relative;
    z-index: 1;
    text-align: center;
    max-width: 64rem;
  }

  .hero-headline {
    margin: 0 0 1.85rem;
    font-size: clamp(2.65rem, 6vw, 5.15rem);
    font-weight: 800;
    line-height: 1.03;
    letter-spacing: -0.02em;
  }

  .headline-top,
  .headline-bottom {
    display: block;
  }

  .headline-top {
    color: rgba(255, 255, 255, 0.98);
  }

  .headline-bottom {
    margin-top: 0.35rem;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.62) 0%, rgba(255, 255, 255, 0.28) 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .headline-rocket {
    margin-left: 0.45rem;
    font-size: 0.72em;
    vertical-align: -0.06em;
    filter: saturate(1.05);
    -webkit-background-clip: initial;
    background-clip: initial;
    -webkit-text-fill-color: initial;
    color: initial;
    background: none;
  }

  /* Typewriter effect */
  .typewriter-text {
    display: inline;
  }

  .typewriter-cursor {
    display: inline-block;
    color: rgba(255, 255, 255, 0.65);
    font-weight: 300;
    margin-left: 1px;
    animation: cursor-blink 1s step-end infinite;
  }

  @keyframes cursor-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  .hero-subheading {
    margin: 0 0 2rem;
    font-size: clamp(1rem, 1.8vw, 1.35rem);
    color: rgba(255, 255, 255, 0.75);
    line-height: 1.7;
  }

  .hero-subheading :global(.desktop-break) {
    display: block;
  }

  @media (max-width: 768px) {
    .hero-subheading :global(.desktop-break) {
      display: none;
    }
  }

  .hero-ctas {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
  }

  .hero-preview {
    margin-top: 3.75rem;
    width: 100%;
    display: flex;
    justify-content: center;
  }

  .preview-stack {
    position: relative;
    /* Stay within container; avoid 100vw which can overflow on mobile (scrollbar/padding) */
    width: 100%;
    max-width: min(1320px, 100vw);
    height: 520px;
  }

  .preview-img-wrap {
    position: absolute;
    border-radius: 22px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow:
      0 28px 70px rgba(0, 0, 0, 0.55),
      0 6px 18px rgba(0, 0, 0, 0.35);
  }

  .preview-img-wrap::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.45) 0%, rgba(0, 0, 0, 0.18) 45%, transparent 100%);
    pointer-events: none;
    border-radius: 22px;
    -webkit-mask-image: var(--mask-url);
    mask-image: var(--mask-url);
    -webkit-mask-size: cover;
    mask-size: cover;
    -webkit-mask-position: center;
    mask-position: center;
    -webkit-mask-repeat: no-repeat;
    mask-repeat: no-repeat;
    -webkit-mask-mode: alpha;
    mask-mode: alpha;
  }

  .preview-img-wrap .preview-center,
  .preview-img-wrap .preview-left,
  .preview-img-wrap .preview-right {
    position: relative;
    display: block;
    border-radius: 22px;
  }

  .preview-img-wrap.preview-center {
    left: 50%;
    top: 56%;
    height: 430px;
    width: max-content;
    max-width: 100%;
    transform: translate(-50%, -50%);
    z-index: 1;
  }

  .preview-img-wrap.preview-center .preview-center {
    height: 100%;
    width: auto;
    max-width: 100%;
    object-fit: contain;
  }

  .preview-img-wrap.preview-left {
    left: 0%;
    bottom: -6%;
    width: min(330px, 26%);
    transform: translate(0, 0);
    z-index: 5;
  }

  .preview-img-wrap.preview-left .preview-left {
    width: 100%;
    height: auto;
    display: block;
  }

  .preview-img-wrap.preview-right {
    right: 0;
    bottom: 18%;
    width: min(480px, 40%);
    z-index: 4;
    opacity: 0.98;
  }

  .preview-img-wrap.preview-right .preview-right {
    width: 100%;
    height: auto;
    display: block;
  }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.65rem;
    height: 50px;
    padding: 0 1.35rem;
    font-size: 1.05rem;
    font-weight: 600;
    border-radius: 999px;
    transition: transform var(--transition), background-color var(--transition), color var(--transition), border-color var(--transition), opacity var(--transition);
  }

  .btn-primary {
    background: rgba(117, 126, 146, 0.9);
    color: rgba(255, 255, 255, 0.96);
    border: 1px solid rgba(255, 255, 255, 0.14);
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.28);
  }

  .btn-primary:hover {
    opacity: 0.98;
    transform: translateY(-1px);
  }

  .btn-secondary {
    background: transparent;
    color: rgba(255, 255, 255, 0.92);
    border: 1px solid transparent;
  }

  .btn-secondary:hover {
    opacity: 0.95;
    transform: translateY(-1px);
  }

  .arrow {
    font-size: 1.15em;
    opacity: 0.95;
  }

  .btn-arrow {
    font-size: 1.15em;
    opacity: 0.9;
    transition: transform 0.2s ease;
  }

  .btn-primary:hover .btn-arrow {
    transform: translateX(2px);
  }

  @media (max-width: 768px) {
    .btn-arrow {
      display: none;
    }
  }

  @media (max-width: 520px) {
    .hero {
      min-height: 560px;
      padding-block: 4.75rem 5.25rem;
    }

    .hero-headline {
      font-size: 2rem;
      margin-bottom: 1.25rem;
    }

    .hero-ctas {
      gap: 0.75rem 1rem;
    }

    .hero-preview {
      margin-top: 2.25rem;
      margin-inline: -1.5rem; /* break out of container padding for edge-to-edge */
      width: calc(100% + 3rem); /* compensate so it's truly full viewport width */
    }

    .preview-stack {
      position: relative;
      height: auto;
    }

    /* Make center image drive the layout instead of fixed height */
    .preview-img-wrap.preview-center {
      position: relative;
      left: 0;
      top: 0;
      width: 100%;
      height: auto;
      transform: none;
      border-radius: 10px;
    }

    .preview-img-wrap.preview-center .preview-center {
      width: 100%;
      height: auto;
      max-width: none;
      object-fit: fill;
      border-radius: 10px;
    }

    .preview-img-wrap.preview-left {
      width: 32%;
      left: 4%;
      bottom: -18%;
    }

    .preview-img-wrap.preview-right {
      width: 42%;
      right: 4%;
      bottom: -4%;
    }
  }
</style>

<script>
  const el = document.querySelector<HTMLSpanElement>('.typewriter-text');
  if (el) {
    const phrases: string[] = JSON.parse(el.dataset.phrases || '[]');
    if (phrases.length > 0) {
      const TYPING_SPEED = 50;
      const DELETING_SPEED = 30;
      const PAUSE_DURATION = 1500;

      let phraseIndex = 0;
      let charIndex = phrases[0].length; // starts fully typed (matches SSR)
      let isDeleting = false;

      function tick() {
        const currentPhrase = phrases[phraseIndex];

        if (isDeleting) {
          charIndex--;
          el!.textContent = currentPhrase.substring(0, charIndex);

          if (charIndex === 0) {
            isDeleting = false;
            phraseIndex = (phraseIndex + 1) % phrases.length;
            setTimeout(tick, TYPING_SPEED);
          } else {
            setTimeout(tick, DELETING_SPEED);
          }
        } else {
          charIndex++;
          el!.textContent = currentPhrase.substring(0, charIndex);

          if (charIndex === currentPhrase.length) {
            isDeleting = true;
            setTimeout(tick, PAUSE_DURATION);
          } else {
            setTimeout(tick, TYPING_SPEED);
          }
        }
      }

      // Pause on the initial phrase (already rendered by SSR), then begin cycling
      setTimeout(() => {
        isDeleting = true;
        tick();
      }, PAUSE_DURATION);
    }
  }
</script>
